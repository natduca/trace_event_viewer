trace_event is a standalone version of Chrome's about:tracing. Should work
on OSX and Linux.

To generate traces viewable by this tool, consider using:
- https://github.com/natduca/py_trace_event

The trace files that trace_viewer understands are insanely simple, so it is
pretty easy to hack up your favorite system to produce them.

QuickStart
===========================================================================

*** Make sure to git submodule update --init after cloning ***

./trace_viewer trace_event/data/big_trace.json
    w/a/s/d to move around the UI

Now, make your favorite language generate trace files, according to
the mini-spec written below!

Dependencies
===========================================================================
Linux:
        python-gtk2
        python-webkit

OSX:
        http://www.wxpython.org/download.php#stable
        wxPython 2.8-osx-unicode-2.6

Windows: Should be possible, but I've got to remove dependencies on
         SVN and things like 'rm' and 'cp'

Trace file format
===========================================================================

A trace file is just an array of events, dumped into a file in
JSON. trace_event_viewer recognizes two different mappings of this array --- the
JSON-formatted array, or a JSON object with a member "traceEvents" containing
the actual events.

The object-wrapped format is:
{
  "traceEvents": [event1,event2,...]
  ... any metadata you want... will be ignored.
}

The array format is:
[event1,event2,...]

The closing ] is optional in the array format. E.g. the following is valid:
[event1,event2,

This is done to support tracing systems that cannot cleanly finish writing the
trace, e.g. during exit.


Trace events
===========================================================================
Events are of the following format:
{
  "ph": "B" | "E" | "I" | "M"
}

Time is currently given in microseconds.

B and E type events correspond to the beginning and end of work
on a given thread:
{
  "ph": "B",
  "ts": 1234523.3, // in microseconds
  "pid": 2343, "tid": 2347,  // indicates event on process 2343 thread 2347
  "name": "MyFunction", // name of function that began
  "args": {}  // any arguments associated with the function 
},
{
  "ph": "E",
  "ts": 1234600, // in microseconds
  "pid": 2343, "tid": 2347,  // indicates event on process 2343 thread 2347
  "name": "MyFunction", // name of function that ended. can be optional
}

B and E events can nest, allowing you to capture function calling behavior on a
thread. For example, this trace is for function A that then calls function
Asub, where Asub takes 2.8us and A takes 3us:
  { ..., ts=1.0, tid=1, ph="B", name="A"},
  { ..., ts=1.1, tid=1, ph="B", name="Asub"},
  { ..., ts=3.9, tid=1, ph="E", name=""},
  { ..., ts=4.0, tid=1, ph="E", name=""},

Events must be sorted in timestamp order PER THREAD but can interleave
between different threads. E.g. you can have:
  { ..., ts=1.0, tid=1, ph="B", name="A"},
  { ..., ts=0.9, tid=2, ph="B", name="B"},
  { ..., ts=1.1, tid=1, ph="E", name=""},
  { ..., ts=4.0, tid=2, ph="E", name=""},

Sometimes, it is necessary to represent operations that are logically part of
a thread, but that occur out-of-band with the function calling stack. For
example, an asynchronous file/ajax/etc reques.  This is currently represented
by B and E events with the magical argument "ui-nest". The following shows
two asynchronous FetchEmail and CheckGPlus requests beginning and ending while also overlapping a regular RedrawScreen operation.

  { ..., ts=1.0, tid=1, ph="B", name="FetchEmail", args={"ui-nest":0},
  { ..., ts=1.1, tid=1, ph="B", name="CheckGPlus", args={"ui-nest":0},
  { ..., ts=1.2, tid=1, ph="E", name="CheckGPlus", args={"ui-nest":0},
  { ..., ts=1.4, tid=1, ph="B", name="RedrawScreen"}
  { ..., ts=1.8, tid=1, ph="E", name=""},
  { ..., ts=1.6, tid=1, ph="E", name="FetchEmail", args={"ui-nest":0},

I phase events correspond to instantaneous events on a thread. For example,
an out of memory condition:
{
  "ph": "I",
  "ts": 1234523.3, // in microseconds
  "pid": 2343, "tid": 2347,  // indicates event on process 2343 thread 2347
  "name": "OutOfMemory", // name of the event
  "args": {}  // any arguments associated with the event
}


M phase events are used to associate metadata with events. For example,
to give a thread a name:
{
  "ph": "M",
  "pid": 2343,
  "tid": 2347,
  "name": "thread_name",
  "args": { "name" : "RendererThread" }
}

