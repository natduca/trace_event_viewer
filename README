trace_event is a standalone version of Chrome's trace_event viewer,
plus some additional code for collecting data outside of chrome.

It is mostly a webapp, so it runs anywhere you can get a Python version of
Webkit to work.

The trace files that trace_viewer understands are insanely simple, so it is
pretty easy to hack up your favorite system to produce them.


Dependencies
===========================================================================
Linux:
        python-gtk2
        python-webkit

OSX, snow leopard:
        wxPython 2.8-osx-unicode-2.6

OSX, others: untested


Trace file format
===========================================================================

The format for trace files is as follows:
{
  "traceEvents": [event list]
  ... any metadata you want...
}

Trace events are of the following format:
{
  "ph": "B" | "E" | "I" | "M"
}

B and E type events correspond to the beginning and end of work
on a given thread:
{
  "ph": "B",
  "ts": 1234523.3, // in microseconds
  "pid": 2343, "tid": 2347,  // indicates event on process 2343 thread 2347
  "name": "MyFunction", // name of function that began
  "args": {}  // any arguments associated with the function 
},
{
  "ph": "E",
  "ts": 1234600, // in microseconds
  "pid": 2343, "tid": 2347,  // indicates event on process 2343 thread 2347
  "name": "MyFunction", // name of function that ended. can be optional
}

B and E events can nest, allowing you to capture function calling behavior on a
thread. For example, this trace is for function A that then calls function
Asub, where Asub takes 2.8us and A takes 3us:
  { ..., ts=1.0, tid=1, ph="B", name="A"},
  { ..., ts=1.1, tid=1, ph="B", name="Asub"},
  { ..., ts=3.9, tid=1, ph="E", name=""},
  { ..., ts=4.0, tid=1, ph="E", name=""},

Events must be sorted in timestamp order PER THREAD but can interleave
between different threads. E.g. you can have:
  { ..., ts=1.0, tid=1, ph="B", name="A"},
  { ..., ts=0.9, tid=2, ph="B", name="B"},
  { ..., ts=1.1, tid=1, ph="E", name=""},
  { ..., ts=4.0, tid=2, ph="E", name=""},

Sometimes, it is necessary to represent operations that are logically part of
a thread, but that occur out-of-band with the function calling stack. For
example, an asynchronous file/ajax/etc reques.  This is currently represented
by B and E events with the magical argument "ui-nest". The following shows
two asynchronous FetchEmail and CheckGPlus requests beginning and ending while also overlapping a regular RedrawScreen operation.

  { ..., ts=1.0, tid=1, ph="B", name="FetchEmail", args={"ui-nest":0},
  { ..., ts=1.1, tid=1, ph="B", name="CheckGPlus", args={"ui-nest":0},
  { ..., ts=1.2, tid=1, ph="E", name="CheckGPlus", args={"ui-nest":0},
  { ..., ts=1.4, tid=1, ph="B", name="RedrawScreen"}
  { ..., ts=1.8, tid=1, ph="E", name=""},
  { ..., ts=1.6, tid=1, ph="E", name="FetchEmail", args={"ui-nest":0},

I phase events correspond to instantaneous events on a thread. For example,
an out of memory condition:
{
  "ph": "I",
  "ts": 1234523.3, // in microseconds
  "pid": 2343, "tid": 2347,  // indicates event on process 2343 thread 2347
  "name": "OutOfMemory", // name of the event
  "args": {}  // any arguments associated with the event
}


M phase events are used to associate metadata with events. For example,
to give a thread a name:
{
  "ph": "M",
  "pid": 2343,
  "tid": 2347,
  "name": "thread_name",
  "args": { "name" : "RendererThread" }
}

